

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    

    
    <title>How to Use Event Queues to Manage Multiple Events &mdash; Apache Mynewt latest documentation</title>
    

    
    
      <link rel="shortcut icon" href="../../_static/mynewt-logo-only-newt32x32.png"/>
    

    

    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

    
      <link rel="stylesheet" href="../../_static/css/sphinx_theme.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/bootstrap-3.0.3.min.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/v2.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    
      <link rel="stylesheet" href="../../_static/css/restructuredtext.css" type="text/css" />
    

    

    <link rel="stylesheet" href="../../_static/css/overrides.css" type="text/css" />
          <link rel="index" title="Index"
                href="../../genindex.html"/>
          <link rel="search" title="Search" href="../../search.html"/>
      <link rel="top" title="Apache Mynewt latest documentation" href="../../index.html"/> 

    
    <script src="../../_static/js/modernizr.min.js"></script>

    
    <script>
    (function(i, s, o, g, r, a, m) {
	i["GoogleAnalyticsObject"] = r;
	(i[r] =
		i[r] ||
		function() {
			(i[r].q = i[r].q || []).push(arguments);
		}),
		(i[r].l = 1 * new Date());
	(a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
	a.async = 1;
	a.src = g;
	m.parentNode.insertBefore(a, m);
})(window, document, "script", "//www.google-analytics.com/analytics.js", "ga");

ga("create", "UA-72162311-1", "auto");
ga("send", "pageview");
</script>
    

  </head>

  <body class="not-front page-documentation" role="document" >
    <div id="wrapper">
      <div class="container">
    <div id="banner" class="row v2-main-banner">
        <a class="logo-cell" href="/">
            <img class="logo" src="../../_static/img/logo.png">
        </a>
        <div class="tagline-cell">
            <h4 class="tagline">An OS to build, deploy and securely manage billions of devices</h4>
        </div>
        <div class="news-cell">
            <div class="well">
                <h4>Latest News:</h4> <a href="/download">Apache Mynewt 1.6.0, Apache NimBLE 1.1.0 </a> released (April 9, 2019)
            </div>
        </div>
    </div>
</div>
      
<header>
    <nav id="navbar" class="navbar navbar-inverse" role="navigation">
        <div class="container">
            <!-- Collapsed navigation -->
            <div class="navbar-header">
                <!-- Expander button -->
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

            </div>

            <!-- Expanded navigation -->
            <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/"><i class="fa fa-home" style="font-size: larger;"></i></a>
                    </li>
                    <li class="important">
                        <a href="/quick-start/">Quick Start</a>
                    </li>
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    <li>
                        <a href="/talks/">Talks</a>
                    </li>
                    <li class="active">
                        <a href="/documentation/">Documentation</a>
                    </li>
                    <li>
                        <a href="/download/">Download</a>
                    </li>
                    <li>
                        <a href="/community/">Community</a>
                    </li>
                    <li>
                        <a href="/events/">Events</a>
                    </li>
                </ul>

                <!-- Search, Navigation and Repo links -->
                <ul class="nav navbar-nav navbar-right">
                    
                </ul>
            </div>
        </div>
    </nav>
</header>
      <!-- STARTS MAIN CONTENT -->
      <div id="main-content">
        





<div id="breadcrumb">
  <div class="container">
    <a href="/documentation/">Docs</a> /
    
    How to Use Event Queues to Manage Multiple Events
    
  <div class="sourcelink">
    <a href="https://github.com/apache/mynewt-core/edit/master/docs/os/tutorials/event_queue.rst" class="icon icon-github"
           rel="nofollow"> Edit on GitHub</a>
</div>
  </div>
</div>
        <!-- STARTS CONTAINER -->
        <div class="container">
          <!-- STARTS .content -->
          <div id="content" class="row">
            
            <!-- STARTS .container-sidebar -->
<div class="container-sidebar col-xs-12 col-sm-3">
  <div id="docSidebar" class="sticky-container">
    <div role="search" class="sphinx-search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search documentation" class="search-documentation" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
    <!-- Note: only works when deployed -->
<select class="form-control" onchange="if (this.value) window.location.href=this.value">
  <option value="/latest" selected>
    Version: latest
  </option>
  <option value="/v1_6_0" >
    Version: 1.6.0
  </option>
  <option value="/v1_5_0" >
    Version: 1.5.0
  </option>
  <option value="/v1_4_0" selected="selected" >
    Version: 1.4.0
  </option>
  <option value="/v1_3_0/os/introduction" >
    Version: 1.3.0
  </option>
  <option value="/v1_2_0/os/introduction" >
    Version: 1.2.0
  </option>
  <option value="/v1_1_0/os/introduction" >
    Version: 1.1.0
  </option>
  <option value="/v1_0_0/os/introduction" >
    Version: 1.0.0
  </option>
  <option value="/v0_9_0/os/introduction" >
    Version: 0.9.0
  </option>
</select>
    <div class="region region-sidebar">
      <div class="docs-menu">
      
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/index.html">Setup &amp; Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../os_user_guide.html">OS User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../network/docs/index.html">BLE User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../newt/index.html">Newt Tool Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../newtmgr/index.html">Newt Manager Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mynewt_faq/index.html">Mynewt FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/index.html">Appendix</a></li>
</ul>

        
      
      </div>
    </div>
  </div>
  <!-- ENDS STICKY CONTAINER -->
</div>
<!-- ENDS .container-sidebar -->

            <div class="col-xs-12 col-sm-9">
              
                <div class="alert alert-warning">
                  <p>
                    Version 1.4.0 is not the most recent version of the
                    Apache Mynewt documentation. Click <a href="/latest">here</a> to
                    read the latest version.
                  </p>
                </div>
              

              
              <div class="">
                <div class="rst-content">
                  <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
                   <div itemprop="articleBody">
                    
  <div class="section" id="how-to-use-event-queues-to-manage-multiple-events">
<h1>How to Use Event Queues to Manage Multiple Events<a class="headerlink" href="#how-to-use-event-queues-to-manage-multiple-events" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The event queue mechanism allows you to serialize incoming events for
your task. You can use it to get information about hardware interrupts,
callout expirations, and messages from other tasks.</p>
<p>The benefit of using events for inter-task communication is that it can
reduce the number of resources that need to be shared and locked.</p>
<p>The benefit of processing interrupts in a task context instead of the
interrupt context is that other interrupts and high priority tasks are
not blocked waiting for the interrupt handler to complete processing. A
task can also access other OS facilities and sleep.</p>
<p>This tutorial assumes that you have read about <a class="reference external" href="../core_os/event_queue/event_queue.html">Event
Queues</a>, the <a class="reference external" href="../modules/hal/hal.html">Hardware
Abstraction Layer</a>, and <a class="reference external" href="../core_os/callout/callout.html">OS
Callouts</a> in the OS User’s Guide.</p>
<p>This tutorial shows you how to create an application that uses events
for:</p>
<ul class="simple">
<li>Inter-task communication</li>
<li>OS callouts for timer expiration</li>
<li>GPIO interrupts</li>
</ul>
<p>It also shows you how to:</p>
<ul class="simple">
<li>Use the Mynewt default event queue and application main task to
process your events.</li>
<li>Create a dedicated event queue and task for your events.</li>
</ul>
<p>To reduce an application’s memory requirement, we recommend that you use
the Mynewt default event queue if your application or package does not
have real-time timing requirements.</p>
</div>
<div class="section" id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<p>Ensure that you have met the following prerequisites before continuing
with this tutorial:</p>
<ul class="simple">
<li>Install the newt tool.</li>
<li>Install the newtmgr tool.</li>
<li>Have Internet connectivity to fetch remote Mynewt components.</li>
<li>Install the compiler tools to support native compiling to build the
project this tutorial creates.</li>
<li>Have a cable to establish a serial USB connection between the board
and the laptop.</li>
</ul>
</div>
<div class="section" id="example-application">
<h2>Example Application<a class="headerlink" href="#example-application" title="Permalink to this headline">¶</a></h2>
<p>In this example, you will write an application, for the Nordic nRF52
board, that uses events from three input sources to toggle three GPIO
outputs and light up the LEDs. If you are using a different board, you
will need to adjust the GPIO pin numbers in the code example.</p>
<p>The application handles events from three sources on two event queues:</p>
<ul class="simple">
<li>Events generated by an application task at periodic intervals are
added to the Mynewt default event queue.</li>
<li>OS callouts for timer events are added to the
<code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code> event queue.</li>
<li>GPIO interrupt events are added to the <code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code>
event queue. #### Create the Project Follow the instructions in the
<a class="reference external" href="nRF52.html">nRF52 tutorial</a> to create a project. #### Create the
Application Create the <code class="docutils literal notranslate"><span class="pre">pkg.yml</span></code> file for the application:</li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">pkg.name: apps/eventq_example</span>
<span class="go">pkg.type: app</span>

<span class="go">pkg.deps:</span>
<span class="go">    - kernel/os</span>
<span class="go">    - hw/hal</span>
<span class="go">    - sys/console/stub</span>
</pre></div>
</div>
<div class="section" id="application-task-generated-events">
<h3>Application Task Generated Events<a class="headerlink" href="#application-task-generated-events" title="Permalink to this headline">¶</a></h3>
<p>The application creates a task that generates events, at periodic
intervals, to toggle the LED at pin <code class="docutils literal notranslate"><span class="pre">TASK_LED</span></code>. The event is queued on
the Mynewt default event queue and is processed in the context of the
application main task.</p>
<p>Declare and initialize the <code class="docutils literal notranslate"><span class="pre">gen_task_ev</span></code> event with the <code class="docutils literal notranslate"><span class="pre">my_ev_cb()</span></code>
callback function to process the event:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>/* Callback function for application task event */
static void my_ev_cb(struct os_event *);

/* Initialize the event with the callback function */
static struct os_event gen_task_ev = {
    .ev_cb = my_ev_cb,
};
</pre></div>
</div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">my_ev_cb()</span></code> callback function to process a task
generated event and toggle the LED at pin <code class="docutils literal notranslate"><span class="pre">TASK_LED</span></code>:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>/* LED 1 (P0.17 on the board) */
#define TASK_LED        17

/*
 * Event callback function for events generated by gen_task. It toggles
 * the LED at pin TASK_LED.
 */
static void my_ev_cb(struct os_event *ev)
{
    assert(ev);
    hal_gpio_toggle(TASK_LED);
    return;
}
</pre></div>
</div>
<p>Create a task that generates an event at periodic intervals and adds,
using the <code class="docutils literal notranslate"><span class="pre">os_eventq_put()</span></code> function, the event to the Mynewt default
event queue:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#define GEN_TASK_PRIO       3
#define GEN_TASK_STACK_SZ   512

static os_stack_t gen_task_stack[GEN_TASK_STACK_SZ];
static struct os_task gen_task_str;

/*
 * Task handler to generate an event to toggle the LED at pin TASK_LED.
 * The event is added to the Mynewt default event queue.
 */
static void
gen_task(void *arg)
{
    while (1) {
        os_time_delay(OS_TICKS_PER_SEC / 4);
        os_eventq_put(os_eventq_dflt_get(), &amp;gen_task_ev);
    }
}

static void
init_tasks(void)
{

    /* Create a task to generate events to toggle the LED at pin TASK_LED */

    os_task_init(&amp;gen_task_str, &quot;gen_task&quot;, gen_task, NULL, GEN_TASK_PRIO,
                 OS_WAIT_FOREVER, gen_task_stack, GEN_TASK_STACK_SZ);

      ...

}
</pre></div>
</div>
<p>Implement the application <code class="docutils literal notranslate"><span class="pre">main()</span></code> function to call the
<code class="docutils literal notranslate"><span class="pre">os_eventq_run()</span></code> function to dequeue an event from the Mynewt default
event queue and call the callback function to process the event.</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>int
main(int argc, char **argv)
{
    sysinit();

    init_tasks();

    while (1) {
       os_eventq_run(os_eventq_dflt_get());
    }
    assert(0);
}
</pre></div>
</div>
</div>
<div class="section" id="os-callout-timer-events">
<h3>OS Callout Timer Events<a class="headerlink" href="#os-callout-timer-events" title="Permalink to this headline">¶</a></h3>
<p>Set up OS callout timer events. For this example, we use a dedicated
event queue for timer events to show you how to create a dedicated event
queue and a task to process the events.</p>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">my_timer_ev_cb()</span></code> callback function to process a timer
event and toggle the LED at pin <code class="docutils literal notranslate"><span class="pre">CALLOUT_LED</span></code>:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>/* LED 2 (P0.18 on the board) */
#define CALLOUT_LED     18

/* The timer callout */
static struct os_callout my_callout;

/*
 * Event callback function for timer events. It toggles the LED at pin CALLOUT_LED.
 */
static void my_timer_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);

    hal_gpio_toggle(CALLOUT_LED);

    os_callout_reset(&amp;my_callout, OS_TICKS_PER_SEC / 2);
}
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">init_tasks()</span></code> function, initialize the
<code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code> event queue, create a task to process
events from the queue, and initialize the OS callout for the timer:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#define MY_TIMER_INTERRUPT_TASK_PRIO  4
#define MY_TIMER_INTERRUPT_TASK_STACK_SZ    512

static os_stack_t my_timer_interrupt_task_stack[MY_TIMER_INTERRUPT_TASK_STACK_SZ];
static struct os_task my_timer_interrupt_task_str;

static void
init_tasks(void)
{
    /* Use a dedicate event queue for timer and interrupt events */

    os_eventq_init(&amp;my_timer_interrupt_eventq);

    /*
     * Create the task to process timer and interrupt events from the
     * my_timer_interrupt_eventq event queue.
     */
    os_task_init(&amp;my_timer_interrupt_task_str, &quot;timer_interrupt_task&quot;,
                 my_timer_interrupt_task, NULL,
                 MY_TIMER_INTERRUPT_TASK_PRIO, OS_WAIT_FOREVER,
                 my_timer_interrupt_task_stack,
                 MY_TIMER_INTERRUPT_TASK_STACK_SZ);
     /*
      * Initialize the callout for a timer event.
      * The my_timer_ev_cb callback function processes the timer events.
      */
    os_callout_init(&amp;my_callout, &amp;my_timer_interrupt_eventq,
                    my_timer_ev_cb, NULL);

    os_callout_reset(&amp;my_callout, OS_TICKS_PER_SEC);

}
</pre></div>
</div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_task()</span></code> task handler to dispatch
events from the <code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code> event queue:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>static void
my_timer_interrupt_task(void *arg)
{
    while (1) {
        os_eventq_run(&amp;my_timer_interrupt_eventq);
    }
}
</pre></div>
</div>
</div>
<div class="section" id="interrupt-events">
<h3>Interrupt Events<a class="headerlink" href="#interrupt-events" title="Permalink to this headline">¶</a></h3>
<p>The application toggles the LED each time button 1 on the board is
pressed. The interrupt handler generates an event when the GPIO for
button 1 (P0.13) changes state. The events are added to the
<code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code> event queue, the same queue as the timer
events.</p>
<p>Declare and initialize the <code class="docutils literal notranslate"><span class="pre">gpio_ev</span></code> event with the
<code class="docutils literal notranslate"><span class="pre">my_interrupt_ev_cb()</span></code> callback function to process the event:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>static struct os_event gpio_ev {
    .ev_cb = my_interrupt_ev_cb,
};
</pre></div>
</div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">my_interrupt_ev_cb()</span></code> callback function to process an
interrupt event and toggle the LED at pin <code class="docutils literal notranslate"><span class="pre">GPIO_LED</span></code>:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>/* LED 3 (P0.19 on the board) */
#define GPIO_LED     19

/*
 * Event callback function for interrupt events. It toggles the LED at pin GPIO_LED.
 */
static void my_interrupt_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);

    hal_gpio_toggle(GPIO_LED);
}
</pre></div>
</div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">my_gpio_irq()</span></code> handler to post an interrupt event to
the <code class="docutils literal notranslate"><span class="pre">my_timer_interrupt_eventq</span></code> event queue:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>static void
my_gpio_irq(void *arg)
{
    os_eventq_put(&amp;my_timer_interrupt_eventq, &amp;gpio_ev);
}
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">init_tasks()</span></code> function, add the code to set up and enable the
GPIO input pin for the button and initialize the GPIO output pins for
the LEDs:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>/* LED 1 (P0.17 on the board) */
#define TASK_LED        17

/*  2 (P0.18 on the board) */
#define CALLOUT_LED     18

/* LED 3 (P0.19 on the board) */
#define GPIO_LED        19

/* Button 1 (P0.13 on the board) */
#define BUTTON1_PIN     13

void
init_tasks()

    /* Initialize OS callout for timer events. */

          ....

    /*
     * Initialize and enable interrupts for the pin for button 1 and
     * configure the button with pull up resistor on the nrf52dk.
     */
    hal_gpio_irq_init(BUTTON1_PIN, my_gpio_irq, NULL, HAL_GPIO_TRIG_RISING, HAL_GPIO_PULL_UP);

    hal_gpio_irq_enable(BUTTON1_PIN);

    /* Initialize the GPIO output pins. Value 1 is off for these LEDs.  */

    hal_gpio_init_out(TASK_LED, 1);
    hal_gpio_init_out(CALLOUT_LED, 1);
    hal_gpio_init_out(GPIO_LED, 1);
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="putting-it-all-together">
<h2>Putting It All Together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete <code class="docutils literal notranslate"><span class="pre">main.c</span></code> source for your application. Build the
application and load it on your board. The task LED (LED1) blinks at an
interval of 250ms, the callout LED (LED2) blinks at an interval of
500ms, and the GPIO LED (LED3) toggles on or off each time you press
Button 1.</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;os/os.h&gt;
#include &lt;bsp/bsp.h&gt;
#include &lt;hal/hal_gpio.h&gt;
#include &lt;assert.h&gt;
#include &lt;sysinit/sysinit.h&gt;


#define MY_TIMER_INTERRUPT_TASK_PRIO  4
#define MY_TIMER_INTERRUPT_TASK_STACK_SZ    512

#define GEN_TASK_PRIO       3
#define GEN_TASK_STACK_SZ   512

/* LED 1 (P0.17 on the board) */
#define TASK_LED        17

/* LED 2 (P0.18 on the board) */
#define CALLOUT_LED     18

/* LED 3 (P0.19 on the board) */
#define GPIO_LED        19

/* Button 1 (P0.13 on the board) */
#define BUTTON1_PIN     13


static void my_ev_cb(struct os_event *);
static void my_timer_ev_cb(struct os_event *);
static void my_interrupt_ev_cb(struct os_event *);

static struct os_eventq my_timer_interrupt_eventq;

static os_stack_t my_timer_interrupt_task_stack[MY_TIMER_INTERRUPT_TASK_STACK_SZ];
static struct os_task my_timer_interrupt_task_str;

static os_stack_t gen_task_stack[GEN_TASK_STACK_SZ];
static struct os_task gen_task_str;

static struct os_event gen_task_ev = {
    .ev_cb = my_ev_cb,
};

static struct os_event gpio_ev = {
    .ev_cb = my_interrupt_ev_cb,
};


static struct os_callout my_callout;

/*
 * Task handler to generate an event to toggle the LED at pin TASK_LED.
 * The event is added to the Mynewt default event queue.
 */

static void
gen_task(void *arg)
{
    while (1) {
        os_time_delay(OS_TICKS_PER_SEC / 4);
        os_eventq_put(os_eventq_dflt_get(), &amp;gen_task_ev);
    }
}

/*
 * Event callback function for events generated by gen_task. It toggles the LED at pin TASK_LED.
 */
static void my_ev_cb(struct os_event *ev)
{
    assert(ev);
    hal_gpio_toggle(TASK_LED);
    return;
}

/*
 * Event callback function for timer events. It toggles the LED at pin CALLOUT_LED.
 */
static void my_timer_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);

    hal_gpio_toggle(CALLOUT_LED);
    os_callout_reset(&amp;my_callout, OS_TICKS_PER_SEC / 2);
}

/*
 * Event callback function for interrupt events. It toggles the LED at pin GPIO_LED.
 */
static void my_interrupt_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);

    hal_gpio_toggle(GPIO_LED);
}

static void
my_gpio_irq(void *arg)
{
    os_eventq_put(&amp;my_timer_interrupt_eventq, &amp;gpio_ev);
}



static void
my_timer_interrupt_task(void *arg)
{
    while (1) {
        os_eventq_run(&amp;my_timer_interrupt_eventq);
    }
}

void
init_tasks(void)
{

    /* Create a task to generate events to toggle the LED at pin TASK_LED */

    os_task_init(&amp;gen_task_str, &quot;gen_task&quot;, gen_task, NULL, GEN_TASK_PRIO,
        OS_WAIT_FOREVER, gen_task_stack, GEN_TASK_STACK_SZ);


    /* Use a dedicate event queue for timer and interrupt events */
    os_eventq_init(&amp;my_timer_interrupt_eventq);

    /*
     * Create the task to process timer and interrupt events from the
     * my_timer_interrupt_eventq event queue.
     */
    os_task_init(&amp;my_timer_interrupt_task_str, &quot;timer_interrupt_task&quot;,
                 my_timer_interrupt_task, NULL,
                 MY_TIMER_INTERRUPT_TASK_PRIO, OS_WAIT_FOREVER,
                 my_timer_interrupt_task_stack,
                 MY_TIMER_INTERRUPT_TASK_STACK_SZ);

    /*
     * Initialize the callout for a timer event.
     * The my_timer_ev_cb callback function processes the timer event.
     */
    os_callout_init(&amp;my_callout, &amp;my_timer_interrupt_eventq,
                    my_timer_ev_cb, NULL);

    os_callout_reset(&amp;my_callout, OS_TICKS_PER_SEC);

    /*
     * Initialize and enable interrupt for the pin for button 1 and
     * configure the button with pull up resistor on the nrf52dk.
     */
    hal_gpio_irq_init(BUTTON1_PIN, my_gpio_irq, NULL, HAL_GPIO_TRIG_RISING, HAL_GPIO_PULL_UP);

    hal_gpio_irq_enable(BUTTON1_PIN);

    hal_gpio_init_out(TASK_LED, 1);
    hal_gpio_init_out(CALLOUT_LED, 1);
    hal_gpio_init_out(GPIO_LED, 1);
}

int
main(int argc, char **argv)
{
    sysinit();

    init_tasks();

    while (1) {
       os_eventq_run(os_eventq_dflt_get());
    }
    assert(0);
}
</pre></div>
</div>
</div>
</div>


                   </div>
                  </div>
                  
                </div>
              </div>
            </div>
            <!-- ENDS CONTENT SECTION -->
          </div>
          <!-- ENDS .content -->
        </div>
      </div>
      <footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-12">
          
              <p class="copyright">Apache Mynewt is available under Apache License, version 2.0.</p>
          
      </div>
      <div class="col-xs-12">
          <div class="logos">
              <img src="../../_static/img/asf_logo_wide_small.png" alt="Apache" title="Apache">
              <small class="footnote">
                Apache Mynewt, Mynewt, Apache, the Apache feather logo, and the Apache Mynewt project logo are either
                registered trademarks or trademarks of the Apache Software Foundation in the United States and other countries.
              </small>
              <a href="">
                <img src="../../_static/img/add_to_slack.png" alt="Slack Icon" title="Join our Slack Community" />
              </a>
          </div>
      </div>
    </div>
  </div>
</footer>
    </div>
    <!-- ENDS #wrapper -->

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'latest',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../_static/js/bootstrap-3.0.3.min.js"></script>
      <script type="text/javascript" src="../../_static/js/affix.js"></script>
      <script type="text/javascript" src="../../_static/js/main.js"></script>

   

  </body>
</html>