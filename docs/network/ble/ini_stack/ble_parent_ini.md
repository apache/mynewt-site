## Create the host parent task

The NimBLE stack requires an application task to function.  One application
task in particular is designated as the *host parent task*.  In addition to
application-specific work, the host parent task does work for NimBLE by
processing events generated by the host.

The process of creating an OS task is described in the [Add Task
tutorial](../../../../os/tutorials/event_queue/).

**Priority:**
It is up to you which priority to use for the host parent task.  Unlike the
controller, the host does not have any strict timing requirements, so the
priority should be based on the application's needs.  In the below example, we
use a priority of **1**.

**Stack size:**
The host parent task's stack needs to be sufficiently large to handle BLE
operations.  This depends on the set of BLE features your application uses, and
on the specifics application callbacks that the stack is configured to use.  A
safe value is to use here is **300 words**; that is the value used in the below
example.

The parent task must do two things:

* Call `ble_hs_start()` before starting its task loop.
* Handle *OS_EVENT_T_TIMER* events within its task loop.

The `ble_hs_start()` function is declared as follows:

```c
int ble_hs_start(void)
```

The `ble_hs_start()` function causes the host to send a sequence of HCI
commands to the controller.  This sequence of commands is necessary for the
host and controller to remain in sync.

We add an application task to our example below.

```c hl_lines="1 3 4 6 7 9 10 11 13 14 15 16 17 18 19 20 21 23 24 26 27 28 29 30 31 32 33 34 35 36 37 38 39 81 82 83 84 85"
#include "os/os.h"

/** Application task. */
static struct os_task app_task;

/** Application task event queue. */
static struct os_eventq app_evq;

/** Application task stack. */
#define APP_STACK_SIZE          (OS_STACK_ALIGN(300))
static os_stack_t app_stack[APP_STACK_SIZE];

/**
 * Application task.
 */
static void
app_task_handler(void *arg)
{
    struct os_callout_func *cf;
    struct os_event *ev;
    int rc;

    rc = ble_hs_start();
    assert(rc == 0);

    while (1) {
        ev = os_eventq_get(&app_evq);
        switch (ev->ev_type) {
        case OS_EVENT_T_TIMER:
            cf = (struct os_callout_func *)ev;
            assert(cf->cf_func);
            cf->cf_func(cf->cf_arg);
            break;
        default:
            assert(0);
            break;
        }
    }
}

int
main(void)
{
	int rc;

    /* Initialize OS */
    os_init();

    /* Set cputime to count at 1 usec increments */
    rc = cputime_init(1000000);
    assert(rc == 0);

    /* Create memory pool for Nimble packets and register with Msys */
    rc = os_mempool_init(&g_mbuf_mempool, MBUF_NUM_MBUFS,
            MBUF_MEMBLOCK_SIZE, &g_mbuf_buffer[0], "mbuf_pool");
    assert(rc == 0);

    rc = os_mbuf_pool_init(&g_mbuf_pool, &g_mbuf_mempool, MBUF_MEMBLOCK_SIZE,
                           MBUF_NUM_MBUFS);
    assert(rc == 0);

    rc = os_msys_register(&g_mbuf_pool);
    assert(rc == 0);

    /* Initialize our device address */
    g_dev_addr[0] = 0x33;
    g_dev_addr[1] = 0x22;
    g_dev_addr[2] = 0x11;
    g_dev_addr[3] = 0xcc;
    g_dev_addr[4] = 0xbb;
    g_dev_addr[5] = 0x0a;

	/* Initialize the statistics package */
    rc = stats_module_init();
    assert(rc == 0);

    /* Initialize the BLE LL */
    rc = ble_ll_init(0, 7, 260);
    assert(rc == 0);

    /* Initialize the application task. */
    os_eventq_init(&app_evq);
    os_task_init(&app_task, "app", app_task_handler, NULL, 1, OS_WAIT_FOREVER,
                 app_stack, APP_STACK_SIZE);

    /* Start the OS */
    os_start();

    /* os start should never return. If it does, this should be an error */
    assert(0);
}
```
